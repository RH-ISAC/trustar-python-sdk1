from __future__ import print_function

import json
import time
from datetime import datetime

import configparser
import dateutil.parser
import pytz
import requests
import requests.auth
from builtins import object
from future import standard_library
from requests import HTTPError
from tzlocal import get_localzone

standard_library.install_aliases()

client_version = "0.2.5"

class TruStar(object):
    """
    Main class you to instantiate the TruStar API
    """

    def __init__(self, config_file="trustar.conf",
                       config_role="trustar",
                       client_type="PYTHON_SDK",
                       client_version=client_version,
                       client_metatag=None,
                       verify=True):

        self.enclaveIds = []

        self.client_type = client_type
        self.client_version = client_version
        self.client_metatag = client_metatag

        self.verify = verify

        config_parser = configparser.RawConfigParser()
        config_parser.read(config_file)

        try:
            # parse required properties
            self.auth = config_parser.get(config_role, 'auth_endpoint')
            self.base = config_parser.get(config_role, 'api_endpoint')
            self.apikey = config_parser.get(config_role, 'user_api_key')
            self.apisecret = config_parser.get(config_role, 'user_api_secret')

            # parse enclaves
            if config_parser.has_option(config_role, 'enclave_ids'):
                self.enclaveIds = [i for i in config_parser.get(config_role, 'enclave_ids').split(',') if i is not None]
        except Exception as e:
            print("Problem reading config file: %s", e)
            raise

    @staticmethod
    def normalize_timestamp(date_time):
        """
        Attempt to convert a string timestamp in to a TruSTAR compatible format for submission.
        Will return current time with UTC time zone if None
        :param date_time: int that is epoch time, or string/datetime object containing date, time, and ideally timezone
        examples of supported timestamp formats: 1487890914, 1487890914000, "2017-02-23T23:01:54", "2017-02-23T23:01:54+0000"
        """
        datetime_dt = datetime.now()

        # get current time in seconds-since-epoch
        current_time = int(time.time())

        try:
            # identify type of timestamp and convert to datetime object
            if isinstance(date_time, int):

                # if timestamp has more than 10 digits, it is in ms
                if date_time > 9999999999:
                    date_time /= 1000

                # if timestamp is incorrectly forward dated, set to current time
                if date_time > current_time:
                    date_time = current_time
                datetime_dt = datetime.fromtimestamp(date_time)
            elif isinstance(date_time, str):
                datetime_dt = dateutil.parser.parse(date_time)
            elif isinstance(date_time, datetime):
                datetime_dt = date_time

        # if timestamp is none of the formats above, error message is printed and timestamp is set to current time by default
        except Exception as e:
            print(e)
            datetime_dt = datetime.now()

        # if timestamp is timezone naive, add timezone
        if not datetime_dt.tzinfo:
            timezone = get_localzone()

            # add system timezone
            datetime_dt = timezone.localize(datetime_dt)

            # convert to UTC
            datetime_dt = datetime_dt.astimezone(pytz.utc)

        # converts datetime to iso8601
        return datetime_dt.isoformat()

    def __get_token(self):
        """
        Retrieves the OAUTH token generated by your API key and API secret.
        this function has to be called before any API calls can be made
        """
        client_auth = requests.auth.HTTPBasicAuth(self.apikey, self.apisecret)
        post_data = {"grant_type": "client_credentials"}
        resp = requests.post(self.auth, auth=client_auth, data=post_data)
        resp.raise_for_status()
        return resp.json()["access_token"]

    def __get_headers(self, is_json=False):
        """
        Create headers dictionary for a request.
        :param is_json: Whether the request body is a json.
        :return: The headers dictionary.
        """
        headers = {
            "Authorization": "Bearer " + self.__get_token(),
        }

        if self.client_type is not None:
            headers["Client-Type"] = self.client_type

        if self.client_version is not None:
            headers["Client-Version"] = self.client_version

        if self.client_metatag is not None:
            headers["Client-Metatag"] = self.client_metatag

        if is_json:
            headers['Content-Type'] = 'application/json'

        return headers

    def __request(self, method, path, headers=None, raise_for_status=True, **kwargs):
        """
        A wrapper around requests.request that handles boilerplate code specific to TruStar's API.
        :param method: The method of the request ("GET", "PUT", "POST", or "DELETE")
        :param path: The path of the request, i.e. the piece of the URL after the base URL
        :param headers: A dictionary of headers that will be merged with the base headers for the SDK
        :param raise_for_status: Whether to raise an exception if the response's status indicates an error
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return: The response object.
        """

        # get headers and merge with headers from method parameter if it exists
        base_headers = self.__get_headers(is_json=method in ["POST", "PUT"])
        if headers is not None:
            base_headers.update(headers)

        # make request
        resp = requests.request(method=method,
                                url="{}/{}".format(self.base, path),
                                headers=base_headers,
                                verify=self.verify,
                                **kwargs)

        if raise_for_status:
            try:
                # raise exception if status code indicates an error
                resp.raise_for_status()
            except HTTPError as e:
                try:
                    # attempt to get error message from json
                    message = "{} {} Error: {}".format(resp.status_code,
                                                       "Client" if resp.status_code < 500 else "Server",
                                                       resp.json()['message'])
                except Exception:
                    # if, for some reason, there is no error message in the json, then raise the original exception
                    raise e
                # raise a new HTTPError with the proper message
                raise HTTPError(message, request=e.request, response=e.response)

        return resp

    def __get(self, path, **kwargs):
        """
        Convenience method for making GET calls.
        :param path: The path of the request, i.e. the piece of the URL after the base URL
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__request("GET", path, **kwargs)

    def __put(self, path, **kwargs):
        """
        Convenience method for making PUT calls.
        :param path: The path of the request, i.e. the piece of the URL after the base URL
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__request("PUT", path, **kwargs)

    def __post(self, path, **kwargs):
        """
        Convenience method for making POST calls.
        :param path: The path of the request, i.e. the piece of the URL after the base URL
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__request("POST", path, **kwargs)

    def __delete(self, path, **kwargs):
        """
        Convenience method for making DELETE calls.
        :param path: The path of the request, i.e. the piece of the URL after the base URL
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__request("DELETE", path, **kwargs)

    def ping(self, **kwargs):
        """
        Ping the API.
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__get("ping", **kwargs).content.decode('utf-8').strip('\n')

    def get_version(self, **kwargs):
        """
        Ping the API.
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        return self.__get("version", **kwargs).content.decode('utf-8').strip('\n')

    def get_reports(self, from_time=None, to_time=None, distribution_type=None, submitted_by=None,
                    enclave_ids=None, **kwargs):
        """
        Retrieves reports filtering by time window, distribution type, ownership, and enclave association
        :param from_time: Optional start of time window (Unix timestamp - seconds since epoch)
        :param to_time: Optional end of time window (Unix timestamp - seconds since epoch)
        :param distribution_type: Optional, restrict reports to specific distribution type
        (by default all accessible reports are returned). Possible values are: 'COMMUNITY' and 'ENCLAVE'
        :param submitted_by: Optional, restrict reports by ownership (by default all accessible reports are returned).
        Possible values are: 'me' and 'others'
        :param enclave_ids: Optional comma separated list of enclave ids, restrict reports to specific enclaves
        (by default reports from all enclaves are returned)
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        params = {'from': from_time, 'to': to_time, 'distributionType': distribution_type,
                  'submittedBy': submitted_by, 'enclaveIds': enclave_ids}
        resp = self.__get("reports", params=params, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def get_report_details(self, report_id, id_type=None, **kwargs):
        """
        Retrieves the report details dictionary
        :param report_id: Incident Report ID
        :param id_type: indicates if ID is internal report guid or external ID provided by the user
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return Incident report dictionary if found, else exception.
        """
        params = {'idType': id_type}
        resp = self.__get("report/%s" % report_id, params=params, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def update_report(self, report_id, id_type=None, title=None, report_body=None, time_began=None,
                      external_url=None, distribution=None, enclave_ids=None, **kwargs):
        """
        Updates report with the given id, overwrites any fields that are provided
        :param report_id: Incident Report ID
        :param id_type: indicates if ID is internal report guid or external ID provided by the user
        :param title: new title for report
        :param report_body: new body for report
        :param time_began: new time_began for report
        :param distribution: new distribution type for report
        :param enclave_ids: new list of enclave ids that the report will belong to (python list or comma-separated list)
        :param external_url: external url of report, optional and is associated with the original source of this report
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """

        params = {'idType': id_type}

        # if enclave_ids field is not null, parse into array of strings
        if enclave_ids:
            # if string, interpret as comma-separated list and convert to python list
            if isinstance(enclave_ids, str) or isinstance(enclave_ids, unicode):
                enclave_ids = enclave_ids.split(',')

            # filter out None values
            if isinstance(enclave_ids, list):
                enclave_ids = [i for i in enclave_ids if i is not None]
            # ensure enclave_ids is a list
            else:
                raise Exception("enclave_ids parameter should be either a list or a comma-separated list in string form")

        payload = {'incidentReport': {'title': title,
                                      'reportBody': report_body,
                                      'timeBegan': self.normalize_timestamp(time_began),
                                      'distributionType': distribution,
                                      'externalUrl': external_url},
                   'enclaveIds': enclave_ids}
        resp = self.__put("report/%s" % report_id, data=json.dumps(payload), params=params, **kwargs)

        return json.loads(resp.content.decode('utf8'))

    def delete_report(self, report_id, id_type=None, **kwargs):
        """
        Deletes the report for the given id
        :param report_id: Incident Report ID
        :param id_type: indicates if ID is internal report guid or external ID provided by the user
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        params = {'idType': id_type}
        resp = self.__delete("report/%s" % report_id, params=params, **kwargs)
        return resp

    def query_latest_indicators(self, source, indicator_types, limit, interval_size, **kwargs):
        """
        Finds all latest indicators
        :param source: source of the indicators which can either be INCIDENT_REPORT or OSINT
        :param indicator_types: a list of indicators or a string equal to "ALL" to query all indicator types extracted
        by TruSTAR
        :param limit: limit on the number of indicators. Max is set to 5000
        :param interval_size: time interval on returned indicators. Max is set to 24 hours
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return json response of the result
        """
        payload = {'source': source, 'types': indicator_types, 'limit': limit, 'intervalSize': interval_size}
        resp = self.__get("indicators/latest", params=payload, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def get_community_trends(self, type, from_time, to_time, page_size, start_page, **kwargs):
        """
        Find community trending indicators.
        :param type: the type of indicators.  3 types are supported: "malware", "cve" (vulnerabilities), "other" (all
        other types of indicators)
        :param from_time: Optional start of time window (Unix timestamp - seconds since epoch)
        :param to_time: Optional end of time window (Unix timestamp - seconds since epoch)
        :param page_size: # of results on returned page
        :param start_page: page to start returning results on
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return: json response of the result
        """

        payload = {
            'type': type,
            'from': from_time,
            'to': to_time,
            'pageSize': page_size,
            'startPage': start_page
        }
        resp = self.__get("community-indicators/trending", params=payload, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def get_correlated_reports(self, indicators, **kwargs):
        """
        Retrieves all TruSTAR reports that contain the searched indicator. You can specify multiple indicators
        separated by commas
        :param indicators: The list of indicators to retrieve correlated reports for.
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        payload = {'q': indicators}
        resp = self.__get("reports/correlate", params=payload, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def query_indicators(self, indicators, limit, **kwargs):
        """
        Finds all reports that contain the indicators and returns correlated indicators from those reports.
        you can specify the limit of indicators returned.
        :param indicators: list of space-separated indicators to search for
        :param limit: max number of results to return
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        payload = {'q': indicators, 'limit': limit}
        resp = self.__get("indicators", params=payload, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def submit_report(self, report_body, title, external_id=None, external_url=None, time_began=datetime.now(),
                      enclave=False, **kwargs):
        """
        Wraps supplied text as a JSON-formatted TruSTAR Incident Report and submits it to TruSTAR Station
        By default, this submits to the TruSTAR community. To submit to your enclave(s), set enclave parameter to True,
        and ensure that the target enclaves' ids are specified in the config file field enclave_ids.
        :param report_body: body of report
        :param title: title of report
        :param external_id: external tracking id of report, optional if user doesn't have their own tracking id that they want associated with this report
        :param external_url: external url of report, optional and is associated with the original source of this report 
        :param time_began: time report began
        :param enclave: boolean - whether or not to submit report to user's enclaves (see 'enclave_ids' config property)
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """

        distribution_type = 'ENCLAVE' if enclave else 'COMMUNITY'
        if distribution_type == 'ENCLAVE' and len(self.enclaveIds) < 1:
            raise Exception("Must specify one or more enclave IDs to submit enclave reports into")

        payload = {'incidentReport': {'title': title,
                                      'externalTrackingId': external_id,
                                      'externalUrl': external_url,
                                      'timeBegan': self.normalize_timestamp(time_began),
                                      'reportBody': report_body,
                                      'distributionType': distribution_type},
                   'enclaveIds': self.enclaveIds}

        resp = self.__post("report", data=json.dumps(payload), timeout=60, **kwargs)
        return resp.json()

    def get_enclave_tags(self, report_id, id_type=None, **kwargs):
        """
        Retrieves the enclave tags present in a specific report
        :param report_id: Incident Report ID
        :param id_type: Optional, indicates if ID is internal report guid or external ID provided by the user
        (default Internal)
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        params = {'idType': id_type}
        resp = self.__get("reports/%s/enclave-tags" % report_id, params=params, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def add_enclave_tag(self, report_id, name, enclave_id, id_type=None, **kwargs):
        """
        Adds a tag to a specific report, in a specific enclave
        :param report_id: Incident Report ID
        :param name: name of the tag to be added
        :param enclave_id: id of the enclave where the tag will be added
        :param id_type: Optional, indicates if ID is internal report guid or external ID provided by the user
        (default Internal)
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        params = {'idType': id_type, 'name': name, 'enclaveId': enclave_id}
        resp = self.__post("reports/%s/enclave-tags" % report_id, params=params, **kwargs)
        return json.loads(resp.content.decode('utf8'))

    def delete_enclave_tag(self, report_id, name, enclave_id, id_type=None, **kwargs):
        """
        Deletes a tag from a specific report, in a specific enclave
        :param report_id: Incident Report ID
        :param name: name of the tag to be deleted
        :param enclave_id: id of the enclave where the tag will be deleted
        :param id_type: Optional, indicates if ID is internal report guid or external ID provided by the user
        (default Internal)
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        """
        params = {'idType': id_type, 'name': name, 'enclaveId': enclave_id}
        resp = self.__delete("reports/%s/enclave-tags" % report_id, params=params, **kwargs)
        return resp.content.decode('utf8')

    def get_report_url(self, report_id):
        """
        Build direct URL to report from its ID
        :param report_id: Incident Report (IR) ID, e.g., as returned from `submit_report`
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return URL
        """

        # Check environment for URL
        base_url = 'https://station.trustar.co' if ('https://api.trustar.co' in self.base) else \
            self.base.split('/api/')[0]

        return "%s/constellation/reports/%s" % (base_url, report_id)

    def get_enclave_ids(self):
        """
        Exposes the enclave ids as fetched from the configuration file
        :param kwargs: Any extra keyword arguments.  These will be forwarded to requests.request.
        :return: list of enclave ids
        """
        return self.enclaveIds
